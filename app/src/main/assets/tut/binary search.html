

<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" >
<style>
.city {
    background-color: white;
    color: blue;
    padding: 5px;
    }
.meme{
  background-color: white ;
    color: black;
    padding: 4px;
    margin-bottom: 10px;
}
.ss{
  background-color: #d3d3d3;
  width: 98%;
  

}
.ma{
  background-color: white;
  margin-right: 10px;
  margin-left: 10px;
  margin-bottom: 10px;
  padding: 5px;
}
</style>
</head>

<body class="ss">
  <p class="meme"> <b>Binary Search</b> &minus; Binary search is a fast search algorithm with run-time complexity of O(log n). This search algorithm works on the principle of divide and conquer. For this algorithm to work properly, the data collection should be in the sorted form.</p>


 <div class="meme">
  <p><b>How binary search works?</b><br>The following is our sorted array and let us assume that we need to search the location of value 31 using binary search.</p>
<img src="binary_search_0.jpg" alt="binary search img" width="100%" height="80">
<p>First, we shall determine half of the array by using this formula &minus;<br>
mid = low + high / 2<br>
Here it is, 0 + 9 / 2 = 4 (integer value of 4.5). So, 4 is the mid of the array.</p>
<img src="binary_search_1.jpg" alt="binary search img" width="100%" height="80">
<p>Now we compare the value stored at location 4, with the value being searched, i.e. 31. We find that the value at location 4 is 27, which is not a match. As the value is greater than 27 and we have a sorted array, so we also know that the target value must be in the upper portion of the array.</p>
<img src="binary_search_2.jpg" alt="binary search img" width="100%" height="80">
<p>We change our low to mid + 1 and find the new mid value again.<br>
low = mid + 1<br>
mid = low + high / 2<br>
Our new mid is 7 now. We compare the value stored at location 7 with our target value 31.</p>
<img src="binary_search_3.jpg" alt="binary search img" width="100%" height="80">
<p>The value stored at location 7 is not a match, rather it is more than what we are looking for. So, the value must be in the lower part from this location.</p>
<img src="binary_search_4.jpg" alt="binary search img" width="100%" height="80">
<p>Hence, we calculate the mid again. This time it is 5.</p>
<img src="binary_search_5.jpg" alt="binary search img" width="100%" height="80">
<p>We compare the value stored at location 5 with our target value. We find that it is a match.</p>
<img src="binary_search_6.jpg" alt="binary search img" width="100%" height="80">
<p>We conclude that the target value 31 is stored at location 5.</p>

</div>


<div class="meme"> 
  <h3>Algorithm</h3>
  <p>Binary Search ( Array A, Value x)<br><br>

Step 1:  Set low = 1 &amp; Set high = n <br>

Step 2: while x is not found repeat steps 3,4,5&amp;6<br>
Step 3: set mid = low + high / 2<br>

Step 4: if A[mid] < x <br>
&emsp;&emsp;set low = mid + 1<br>

Step 5: if A[mid] > x<br>
        &emsp;&emsp; set high = mid - 1<br>

Step 6: if A[mid] = x <br>
        &emsp;&emsp; print x found at location mid<br>
 
Step 7: Exit</p>
  
</div>



<div class="meme">
  <h3>Algorithm Analysis</h3>
  <h4>Worst case analysis</h4>
  <p>In the worst case, the item X does not exist in the array A at all. Through each recursion or iteration of Binary Search, the size of the admissible range is halved. This halving can be done ceiling(lg n ) times. Thus, ceiling(lg n ) comparisons are required. i.e. O(log n) comparsions. </p>

  <h4>Average Case Analysis</h4>
  <p>To find the average case, take the sum over all elements of the product of number of comparsions required to find each element and the probability of searching for that element. To simplify the analysis, assume that no item which is not in A will be searched for, and that the probabilities of searching for each element are uniform. <br>
&emsp;&emsp;&emsp;
The difference between O(log(N)) and O(N) is extremely significant when N is large: for any practical problem it is crucial that we avoid O(N) searches. For example, suppose your array contains 2 billion (2x10&#94;9) values. Linear search would involve about a billion comparisons; binary search would require only 32 comparisons! </p>

  <h4>Best Case Analysis(Bogus) </h4>
  <p>In the best case, the item X is the middle in the array A. A constant number of comparisions (actually just 1) are required. i.e. O(1) comparison.</p>
</div>

  

</body>
</html>
