<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" >
<style>
.city {
    background-color: white;
    color: blue;
    padding: 5px;
    }
.meme{
    background-color: white ;
    color: black;
    padding: 5px;
}
.ss{
    width: 98%;

}
</style>
</head>

<body class="ss">

    <p>Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output. Algorithms are generally created independent of underlying languages, i.e. an algorithm can be implemented in more than one programming language. From the data structure point of view, following are some important categories of algorithms &minus;</p>
    <ul style="list-style: square;">
        <li><b>Insert</b> &minus; Algorithm to insert item in a data structure.</li>
        <li><b>Delete</b> &minus; Algorithm to delete an existing item from a data structure.</li>
        <li><b>Search</b> &minus; Algorithm to search an item in a data structure.</li>
        <li><b>Sort</b> &minus; Algorithm to sort items in a certain order.</li>
        <li><b>Update</b> &minus; Algorithm to update an existing item in a data structure.</li>
    </ul>
    <p><b>Characteristics of an Algorithm</b> &minus;Not all procedures can be called an algorithm. An algorithm should have the following characteristics &minus;</p>
    <ul style="list-style: square;">
        <li><b>Input</b> &minus; An algorithm should have 0 or more well-defined inputs.</li>
        <li><b>Output</b> &minus; An algorithm should have 1 or more well-defined outputs, and should match the desired output.</li>
        <li><b>Unambiguous</b> &minus; Algorithm should be clear and unambiguous. Each of its steps (or phases), and their inputs/outputs should be clear and must lead to only one meaning.</li>
        <li><b>Feasibility</b> &minus; Should be feasible with the available resources.</li>
        <li><b>Finiteness</b> &minus; Algorithms must terminate after a finite number of steps.</li>
    </ul>

    <p><b>Greedy Algorithms</b> &minus; An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen. 
Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions. Most networking algorithms use the greedy approach. Here is a list of few of them</p>
<ul style="list-style: square;">
    <li>Travelling Salesman Problem </li>
    <li>Prim's Minimal Spanning Tree Algorithm </li>
    <li>Kruskal's Minimal Spanning Tree Algorithm</li>
    <li>Dijkstra's Minimal Spanning Tree Algorithm</li>
    <li>Graph - Map Coloring</li>
    <li>Graph - Vertex Cover</li>
    <li>Knapsack Problem</li>
</ul>
<p><b>Divide &amp; Conquer</b> &minus; In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.</p>
<p>The following computer algorithms are based on divide-and-conquer programming approach &minus;</p>
<ul style="list-style: square;">
    <li>Merge Sort</li>
    <li>Quick Sort</li>
    <li>Binary Search</li>
    <li>Strassen's Matrix Multiplication</li>
    <li>Closest Pair (points)</li>
</ul>

</body>
</html>
