Data Structure is a way to defining, storing & retrieving of data in a structural & systematic way. A data structure may contain different type of data items.
Data structure availability may vary by programming languages. Commonly available data structure are linked list , arrays , stack , queues , tree , graphs , etc.
INSERTION - adding a data item. DELETION - removing a data item. TRAVERSAL - accessing and/or printing all data items. SEARCHING - finding a particular data item. SORTING - arranging data items in a predefined sequence.
Data structures is important in almost every aspect where data is involved. In general, algorithms that involve efficient data structure is applied in the following areas: numerical analysis, operating system, A.I., compiler design, database management, graphics, and statistical analysis, to name a few.
Dynamic data structures are structures that expand and contract as a program runs. It provides a flexible means of manipulating data because it can adjust according to the size of the data.
Algorithm is a step by Step Procedure ,  which defines a set of instructions to be executed in certain order to get the desired output.
The type of the algorithm used in solving the 8 Queens problem is Backtracking.
Huffman’s algorithm is associated in creating extended binary trees that has minimum weighted path lengths from the given weights. It makes use of a table that contains frequency of occurrence for each data element.
Algorithm used to search the contents by comparing each element of array is called Brute Force algorithm.
Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems, that incrementally builds candidates to the solutions, and abandons each partial candidate ("backtracks") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
Recursive algorithm targets a problem by dividing it into smaller, manageable sub-problems. The output of one recursion after processing one sub-problem becomes the input to the next recursive process.
Fibonacci search is a search algorithm that applies to a sorted array. It makes use of a divide-and-conquer approach that can greatly reduce the time needed in order to reach the target element.
The Tower of Hanoi (also called the Tower of Brahma or Lucas' Tower[1] and sometimes pluralized) is a mathematical game or puzzle. It consists of three rods and a number of disks of different sizes, which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the; smallest at the top, thus making conical shape.
Asymptotic analysis can provide three levels of mathematical binding of execution time of an algorithm. Best case is represented by  Ω(n) notation. Worst case is represented by 0(n) notation. Average case is represented by  Θ(n) notation.
The way in which the amount of storage space required by an algorithm varies with the size of the problem it is solving. Space complexity is normally expressed as an order of magnitude, e.g. O(N^2) means that if the size of the problem (N) doubles then four times as much working storage will be needed.
Time complexity of an algorithm quantifies the amount of time taken by an algorithm to run as a function of the length of the input. Similarly, Space complexity of an algorithm quantifies the amount of space or memory taken by an algorithm to run as a function of the length of the input.
Notations used in Evaluation of Arithmetic Expressions using prefix and postfix forms are Polish and Reverse Polish notations.
Infix notation: X + Y – Operators are written in-between their operands. This is the usual way we write expressions. An expression such as  :- A * ( B + C ) / D
Postfix notation (also known as “Reverse Polish notation”): X Y + Operators are written after their operands. The infix expression given above is equivalent to :- A B C + * D/
Prefix notation (also known as “Polish notation”): + X Y Operators are written before their operands. The expressions given above are equivalent to  :- / * A + B C D
GREEDY APPROACH:- finding solution by choosing next best option.  DIVIDE AND CONQUER:- dividing the problem to a minimum possible sum-problem and solving them independently. DYNAMIC PROGRAMMING:- dividing the problem to a minimum possible sum-problem and solving them combined.
A linear data structure has sequentially arranged data items. The next data can be stored in next memory block. It can stored and accessed in sequential manner. array , linked list, stack , etc. are example of linear data structure.
A non linear data structure is a data structure in which a data item is connected  non sequentially to several other data items. So that a given data item has the possibility to reach one-or-more data items.tree , graphs , heaps , etc. are example of non linear data structure.
Stack. Because of its LIFO (Last In First Out) property it remembers its caller, so knows whom to return when the function has to return. Recursion makes use of system stack for storing the return addresses of the function calls. Every recursive function has its equivalent iterative (non-recursive) function. Even when such equivalent iterative procedures are written, explicit stack is to be used.
The amount of memory to be allocated or reserved would depend on the data type of the variable being declared. For example, if a variable is declared to be of integer type, then 32 bits of memory storage will be reserved for that variable.
Most declarations do, with the exemption of pointers. Pointer declaration does not allocate memory for data, but for the address of the pointer variable. Actual memory allocation for the data comes during run-time.
When dealing with arrays, data is stored and retrieved using an index that actually refers to the element number in the data sequence. This means that data can be accessed in any order. In programming, an array is declared as a variable having a number of indexed elements.
Multidimensional arrays make use of multiple indexes to store data. It is useful when storing data that cannot be represented using a single dimensional indexing, such as data representation in a board game, tables with data stored in more than one column.
The size of the arrays is fixed, Linked Lists are Dynamic in size. Inserting and deleting a new element in an array of elements is expensive, Whereas both insertion and deletion can easily be done in Linked Lists. Random access is not allowed in Linked Listed. Extra memory space for a pointer is required with each element of the Linked list. Arrays have better cache locality that can make a pretty big difference in performance.
Dynamic memory allocation helps from being able to store simple structured data types to combine all the separately allocated structured blocks to form composite structures that expand and contract as needed.
Ordering the data in an increasing or decreasing fashion according to some relationship among the data item is called sorting.
A bubble sort is one sorting technique that can be applied to data structures such as an array. It works by comparing adjacent elements and exchanges their values if they are out of order. This method lets the smaller values “bubble” to the top of the list, while the larger value sinks to the bottom.
The quick sort algorithm is of the divide and conquer type. That means it works by reducing a sorting problem into several easier sorting problems and solving each of them. A dividing value is chosen from the input data, and the data is partitioned into three sets: elements that belong before the dividing value, the value itself, and elements that come after the dividing value. The partitioning is performed by exchanging elements that are in the first set but belong in the third with elements that are in the third set but belong in the first Elements that are equal to the dividing element can be put in any of the three sets the algorithm will still work properly.
The merge sort is a divide and conquer sort as well. It works by considering the data to be sorted as a sequence of already-sorted lists (in the worst case, each list is one element long). Adjacent sorted lists are merged into larger sorted lists until there is a single sorted list containing all the elements. The merge sort is good at sorting lists and other data structures that are not in arrays, and it can be used to sort things that don't fit into memory. It also can be implemented as a stable sort.
The radix sort takes a list of integers and puts each element on a smaller list, depending on the value of its least significant byte. Then the small lists are concatenated, and the process is repeated for each more significant byte until the list is sorted. The radix sort is simpler to implement on fixed-length data such as ints.
Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort,if the smaller value is to the far right and has to be moved to the far lef.This algorithm uses insertion sort on a widely spread elements,first to sort them and then sorts the less widely spaced elements.
LIFO is short for Last In First Out, and refers to how data is accessed, stored and retrieved. Using this scheme, data that was stored last , should be the one to be extracted first. This also means that in order to gain access to the first data, all the other data that was stored before this first data must first be retrieved and extracted.
Stack is a linear data structure which the order LIFO(Last In First Out) or FILO(First In Last Out) for accessing elements. Basic operations of stack are : Push, Pop , Peek .   Applications of Stack: Infix to Postfix Conversion using Stack. Evaluation of Postfix Expression . Reverse a String using Stack. Implement two stacks in an array. Check for balanced parentheses in an expression
Data that is stored in a stack follows a LIFO pattern. This means that data access follows a sequence wherein the last data to be stored will the first one to be extracted. Arrays, on the other hand, does not follow a particular order and instead can be accessed by referring to the indexed element within the array.
Stacks can be described as pointers because stack will contain a head pointer which will always point to the top of the Stack.All Stack Operations are done using Head Pointer.
FIFO is short for First-in, First-out, and is used to represent how data is accessed in a queue. Data has been inserted into the queue list the longest is the one that is removed first.
Queue is a linear structure which follows the order is First In First Out (FIFO) to access elements. Mainly the following are basic operations on queue: Enqueue, Dequeue, Front, Rear. The difference between stacks and queues is in removing. In a stack we remove the item the most recently added in a queue, we remove the item the least recently added. Both Queues and Stacks can be implemented using Arrays and Linked Lists.
A dequeue, also known as a double-ended queue, is an ordered collection of items similar to the queue. It has two ends, a front and a rear, and the items remain positioned in the collection. What makes a deque different is the unrestrictive nature of adding and removing items. New items can be added at either the front or the rear. Likewise, existing items can be removed from either end. In a sense, this hybrid linear structure provides all the capabilities of stacks and queues in a single data structure.
A priority queue is a queue which has a collection of elements such that each element has been assigned a priority.
Two Queue is needed. One queue is used for actual storing of data and another for storing priorities.
A linked list is a linear data structure (like arrays) where each element is a separate object. Each element (that is node) of a list is comprising of two items – the data and a reference to the next node.Types of Linked List : 1. Singly linked list , 2. Doubly Linked List , 3. Circular Linked List
An ordered list is a list in which each node’s position in the list is determined by the value of its key component, so that the key values form an increasing sequence, as the list is traversed.
Header of the linked list is the first element in the list and it stores the number of elements in the list. It points to the first data element of the list.
The heterogeneous linked list contains different data types in its nodes and we need a link, pointer to connect them. It is not possible to use ordinary pointers for this. So we go for void pointer. Void pointer is capable of storing pointer to any type as it is a generic pointer type.
Tree is a very popular data structure used in wide range of applications. A  Tree is a non-linear data structure which organizes data in hierarchical structure and this is a recursive definition. A tree data structure can also be defined as  a collection of data (Node) which is organized in hierarchical structure and this is a recursive definition In tree data structure, every individual element is called as Node. Node in a tree data structure, stores the actual data of that particular element and link to next element in hierarchical structure.
In a directed tree any node which has out degree o is called a leaf.It is also known as terminal node.
A binary tree is a set of data items which is either empty or consists of a single item called the root and two disjoint binary trees called left subtree and right subtree. A binary tree is a very important and the most commonly used non-linear data structure. In a binary tree the maximum degree of any node is at most two.
A general tree is a data structure in that each node can have infinite number of children, A Binary tree is a data structure in that each node has at most two nodes left and right. There is no limit on the degree of node in a general tree. Nodes in a binary tree cannot have more than degree 2.
A Binary Search Tree (BST) is a tree in which all the nodes follow these properties  -  The left sub-tree of a node has a key less than or equal to its parent node's key And the right sub-tree of a node has a key greater than to its parent node's key. Thus, BST divides all its sub-trees into two segments;  the left sub-tree and the right sub-tree and can be defined as − [ left_subtree (keys)  ≤  node (key)  ≤  right_subtree (keys) ]
Complete binary trees and full binary trees have a clear difference. While a full binary tree is a binary tree in which every node has zero or two children, a complete binary tree is a binary tree in which every level of the binary tree is completely filled except the last level. Some special data structures like heaps need to be complete binary trees while they don’t need to be full binary trees. In a full binary tree, if you know the number of total nodes or the number of leaves or the number of internal nodes, you can find the other two very easily.
An AVL tree (named after inventors Adelson-Velsky and Landis) is a self-balancing binary search tree. It was the first such data structure to be invented In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations.balancing factor of AVL tree lie between the -1 to 1.
In a binary tree the balance factor of a node N is defined to be the height difference of its two child subtrees. A binary tree is defined to be an AVL tree if the invariant BalanceFactor(N) ∈ {–1,0,+1} holds for every node N in the tree.  A node N with BalanceFactor(N) < 0 is called "left-heavy", one with BalanceFactor(N) > 0 is called "right-heavy", and one with BalanceFactor(N) = 0 is sometimes simply called "balanced".
Rotation is the process of moving the nodes to either left or right to make tree balanced. In AVL tree, after performing every operation like insertion and deletion we need to check the balance factor of every node in the tree. If every node satisfies the balance factor condition then we conclude the operation otherwise we must make it balanced. We use rotation operations to make the tree balanced whenever the tree is becoming imbalanced due to any operation. Rotation operations are used to make a tree balanced.
A graph is one type of data structure that contains a set of ordered pairs. These ordered pairs are also referred to as edges or arcs, and are used to connect nodes where data can be stored and retrieved.
A spanning tree is a tree associated with a network. All the nodes of the graph appear on the tree once. A minimum spanning tree is a spanning tree organized so that the total edge weight between nodes is minimized.
A minimum spanning tree (MST) or minimum weight spanning tree is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. That is, it is a spanning tree whose sum of edge weights is as small as possible. More generally, any edge-weighted undirected graph (not necessarily connected) has a minimum spanning forest, which is a union of the minimum spanning trees for its connected components.
Kruskal's algorithm is a minimum-spanning-tree algorithm which finds an edge of the least possible weight that connects any two trees in the forest.It is a greedy algorithm in graph theory as it finds a minimum spanning tree for a connected weighted graph adding increasing cost arcs at each step. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).
Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. One starts at the root (selecting some arbitrary node as the root in the case of a graph) and explores as far as possible along each branch before backtracking.
Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a 'search key') and explores the neighbor nodes first, before moving to the next level neighbours. BFS and its application in finding connected components of graphs were invented in 1945 by Michael Burke and Konrad Zuse, in his (rejected) Ph.D.
No, the spanning tree of a graph does not give the shortest distance between any 2 specified nodes. The Minimal spanning tree assures that the total weight of the tree is kept at its minimum. But it doesn't mean that the distance between any two nodes involved in the minimum-spanning tree is minimum.
Hashing is a technique to convert a range of key values into a range of indexes of an array. We're going to use modulo operator to get a range of key values.  Data Item are in the (key,value) format.
Hash Table is a data structure which stores data in an associative manner. In a hash table, data is stored in an array format, where each data value has its own unique index value. Access of data becomes very fast if we know the index of the desired data.
Two keys mapping to the same location in the hash table is called Collision. Collisions can be reduced with a selection of a good hash function. But it is not possible to avoid collisions altogether.
Linear probing is a scheme in computer programming for resolving collisions in hash tables, data structures for maintaining a collection of key–value pairs and looking up the value associated with a given key. ... Along with quadratic probing and double hashing, linear probing is a form of open addressing.






